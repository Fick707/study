# jdk 锁与并发

## jvm锁的实现

* 对象头信息中，markword部分是实现锁的关键

## jdk内置锁优化

* 偏向锁
	* 如果没有竞争关系，则取消第二次获取锁时的同步操作。即若一个线程已经获得过锁，即进入偏向模式，当线程再获取这个锁时，无需要进行相关的同步操作；
	* 偏向锁在少量竞争时，效果比较好；当大量竞争出现时，持有锁的线程在不断切换，所以很难保持偏向模式；
* 轻量级锁
	* 如果偏向锁失败，jvm会让线程申请轻量级锁；
	* 轻量级锁的实现：使用一个BasicObjectLock实现；该对象存在于java栈中的栈帧中，且其指针放在对象头的markword中，判断一个线程是否持有该对象，只需要判断对象头的指针是否在该线程的栈地址范围内；
* 膨胀锁
	* 当轻量级锁申请失败时，jvm就会使用重量级锁（由轻量级锁膨胀为重量级锁）；
	* 放弃对象头markword中的轻量级锁信息-->启用重量级锁（调用inflate()方法膨胀，获得ObjectMonitor-->调用ObjectMonitor的enter()方法进入该锁）
	* 在启用重量级锁时，enter()进入锁时，可能会被挂起，线程之切换和调度的成本就会非常高；
* 自旋锁
	* 重量级锁在进入enter()后，线程切换成本非常高，所以jvm会做最后的争取：自旋；
	* 自旋即在线程被挂起之前，循环多次，尝试重新获取锁，失败多次之后才会放弃；
	* 自旋锁在竞争相对较少，线程占用时间较少的情况下具有积极作用；但在竞争激烈的场景下，可能反而会导致资源浪费（空循环多次后放弃）；
* 消除锁
	* 消除锁是jvm在JIT编译时，通过对上下文扫描，去除不可能存在的共享资源竞争的锁；

## 锁在应用层的优化思路

* 减少锁持有时间
* 减少锁的粒度
	* concurrentHashMap就是典型的例子，分段锁；
* 分离锁
	* LinkedBlockingQueue就是典型的例子，take和put分别操作队列的头和尾，将头和尾的锁分离；
* 锁粗化
	* jvm在遇到一连串的地对同一锁进行请求和释放时，便会把所有锁操作整合成一次请求；
* 无锁

## 无锁

* ThreadLocal就是一种无锁实现，每个线程拥有各自的变量副本；
* CAS（Compare and Swap)对比交换。
	* cas(v,e,n)三个参数，v:变量；e:预期值；n:新值；当变量的的值与预期值一样时，才会将n值赋给变量，会返回变量的最新值；
	* Atomic是jdk中的一系列实现；
	* jdk8 LongAdder

## 变随机为可控

* 原子性
	* 赋值操作是原子操作；
	* 在32位的操作系统中给long,double类型赋值也不是原子性的，因为它们是64位的数据类型，不能一次性操作；可能会出现意想不到的结果；使用volitile可解决
	* a ++ 不是原子操作；（因为它包含读取、计算、写入多个步骤）；
